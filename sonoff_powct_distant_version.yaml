esphome:
  name: my-sonoff-powct
  friendly_name: my Sonoff POWCT

esp32:
  board: nodemcu-32s
  framework:
    type: esp-idf

logger:
   level: INFO

api:
  encryption:
    key: ">>>>>>>>PUT HERE YOUR OWN KEY<<<<<<<<<<<"
  reboot_timeout: 5min
  homeassistant_services: True
  services:
    - service: read_register
      variables:
        register_number: string
        size: int
      then:
        - lambda: |-
            id(cse7761_comp).read_register_service(register_number, size);
    - service: write_register
      variables:
        register_number: string
        regiter_value: string
      then:
        - lambda: |-
            id(cse7761_comp).write_register_service(register_number, regiter_value);

ota:
  - platform: esphome
    password: ">>>>>>>>PUT HERE YOUR OWN PASSWORD<<<<<<<<<<<"

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  ap:
    ssid: ">>>>>>>>PUT HERE YOUR OWN FALLBACK SSID<<<<<<<<<<<"
    password: ">>>>>>>>PUT HERE YOUR OWN PASSWORD<<<<<<<<<<<"

web_server:
  ota: false
  log: false
  local: true
  version: 3

captive_portal:

time:
  - platform: homeassistant
    id: homeassistant_time

external_components:
  - source: github://mazkagaz/sonoff_powct_esphome@main
    components: [cse7761] # components to be taken remotely

uart:
  tx_pin: GPIO26
  rx_pin: GPIO25
  baud_rate: 38400
  parity: EVEN
  stop_bits: 1

# Debug text_sensor : cse7761 register acces
text_sensor:
  - platform: template
    id: lecture_registre_debug_hex
    name: "CSE7761 Lecture Registre (hexa)"
    entity_category: diagnostic
  - platform: template
    id: lecture_registre_debug_bin
    name: "CSE7761 Lecture Registre (binaire)"
    entity_category: diagnostic
    
sensor:
  - platform: cse7761
    id: cse7761_comp
    update_interval: 2s
    debug_sensor_hex_id: lecture_registre_debug_hex
    debug_sensor_bin_id: lecture_registre_debug_bin
    voltage:
      name: Voltage
      id: v_sensor
      unit_of_measurement: 'V'
      icon: mdi:sine-wave
    current_1:
      name: Current A
      id: a_sensor_1
      unit_of_measurement: 'A'
      accuracy_decimals: 3
      icon: mdi:current-ac
# current_2 only for debug purpose
#    current_2:
#      name: Current B
#      id: a_sensor_2
#      unit_of_measurement: 'A'
#      accuracy_decimals: 3
#      icon: mdi:current-ac
    active_power_1:
      name: Power A
      id: w_sensor_1
      icon: mdi:flash
      on_value_range:
        - above: 4.0
          then:
            - light.turn_on: switch_led
        - below: 3.0
          then:
            - light.turn_off: switch_led
# active_power_2 only for debug purpose
#    active_power_2:
#      name: Power B
#      id: w_sensor_2
#      icon: mdi:flash
#      on_value_range:
#        - above: 4.0
#          then:
#            - light.turn_on: switch_led
#        - below: 3.0
#          then:
#            - light.turn_off: switch_led

  - platform: total_daily_energy
    name: Total Daily Energy
    power_id: w_sensor
    id: kw_sensor
    unit_of_measurement: 'kWh'
    state_class: total_increasing
    device_class: energy
    accuracy_decimals: 3
    icon: mdi:lightning-bolt
    filters:
      # Multiplication factor from W to kW is 0.001
      - multiply: 0.001

  - platform: internal_temperature
    name: ESP32 Internal Temp
    id: esp32_temp
    update_interval: 60s

  - platform: template
    name: Power Factor
    device_class: power_factor
    id: power_factor
    icon: mdi:angle-acute
    lambda: return id(w_sensor).state / id(v_sensor).state / id(a_sensor).state;

binary_sensor:
  - platform: gpio
    pin: GPIO00
    id: reset
    internal: true
    filters:
      - invert:
      - delayed_off: 10ms
    on_click:
      - max_length: 350ms # short press to toggle the relay
        then:
          switch.toggle: relay_1
      - min_length: 360ms # long press to cycle display info
        max_length: 3s
        then:
          - if:
              condition:
                binary_sensor.is_on: page
              then:
                binary_sensor.template.publish:
                  id: page
                  state: OFF
              else:
                binary_sensor.template.publish:
                  id: page
                  state: ON
  - platform: template # this is a fake sensor to tell the screen which info to show on display
    id: page
    publish_initial_state: true
    internal: true

display:
  platform: tm1621
  id: tm1621_display
  cs_pin: GPIO17
  data_pin: GPIO05
  read_pin: GPIO23
  write_pin: GPIO18
  lambda: |-
    if (id(page).state) {
      it.display_voltage(true);
      it.display_kwh(false);
      it.printf(0, "%.1f", id(v_sensor).state);
      it.printf(1, "%.1f", id(a_sensor).state);
    } else {  
      it.display_voltage(false);
      it.display_kwh(true);
      it.printf(0, "%.1f", id(kw_sensor).state);
      it.printf(1, "%.1f", id(w_sensor).state);
    }

output:
  - platform: ledc
    id: led
    pin:
      number: GPIO13
      inverted: False

switch:
  - platform: template
    name: CSE7761 Calibration Mode
    id: cse7761_calibration_switch
    icon: mdi:ruler
    # L'état est toujours OFF par défaut (calibration désactivée)
    optimistic: true
    turn_on_action:
      - lambda: 'id(cse7761_comp).set_calibration_mode(true);'
    turn_off_action:
      - lambda: 'id(cse7761_comp).set_calibration_mode(false);'
  - platform: gpio
    name: Relay
    pin: GPIO21
    id: relay_1
    restore_mode: RESTORE_DEFAULT_OFF
    on_turn_on:
      - delay: 500ms
      - light.turn_on: switch_led
    on_turn_off:
      - delay: 500ms
      - light.turn_off: switch_led

light:
  - platform: monochromatic
    id: switch_led
    output: led
    internal: True
  - platform: status_led
    id: wifi_status_led
    internal: True
    pin:
      number: GPIO15
      inverted: True

